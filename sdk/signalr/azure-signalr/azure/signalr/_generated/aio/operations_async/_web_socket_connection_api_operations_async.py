# coding=utf-8
# --------------------------------------------------------------------------
# Code generated by Microsoft (R) AutoRest Code Generator (autorest: 3.0.6262, generator: {generator})
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
from typing import Any, Callable, Dict, Generic, List, Optional, TypeVar, Union
import warnings

from azure.core.exceptions import HttpResponseError, ResourceExistsError, ResourceNotFoundError, map_error
from azure.core.pipeline import PipelineResponse
from azure.core.pipeline.transport import AsyncHttpResponse, HttpRequest

T = TypeVar('T')
ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]

class WebSocketConnectionApiOperations:
    """WebSocketConnectionApiOperations async operations.

    You should not instantiate this class directly. Instead, you should create a Client instance that
    instantiates it for you and attaches it as an attribute.

    :param client: Client for service requests.
    :param config: Configuration of service client.
    :param serializer: An object model serializer.
    :param deserializer: An object model deserializer.
    """

    def __init__(self, client, config, serializer, deserializer) -> None:
        self._client = client
        self._serialize = serializer
        self._deserialize = deserializer
        self._config = config

    async def post_default_hub_broadcast(
        self,
        data: Union[str, str],
        excluded: Optional[List[str]] = None,
        **kwargs
    ) -> None:
        """Broadcast content inside request body to all the connected to endpoint "/ws/client".

        Broadcast content inside request body to all the connected to endpoint "/ws/client".

        :param data:
        :type data: str, str
        :param excluded: Excluded connection Ids.
        :type excluded: list[str]
        :keyword str content_type: Media type of the body sent to the API.
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        content_type = kwargs.pop("content_type", "application/octet-stream")

        # Construct URL
        url = self.post_default_hub_broadcast.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if excluded is not None:
            query_parameters['excluded'] = self._serialize.query("excluded", excluded, '[str]')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')

        # Construct and send request
        body_content_kwargs = {}  # type: Dict[str, Any]
        if header_parameters['Content-Type'] in ['application/octet-stream']:
            body_content_kwargs['stream_content'] = data
        elif header_parameters['Content-Type'] in ['text/plain']:
            body_content = self._serialize.body(data, 'str')
            body_content_kwargs['content'] = body_content
        else:
            raise ValueError(
                "Content type {} is not valid for this operation".format(header_parameters['Content-Type'])
            )
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
          return cls(pipeline_response, None, {})

    post_default_hub_broadcast.metadata = {'url': '/ws/api/v1'}  # type: ignore

    async def post_broadcast(
        self,
        hub: str,
        data: Union[str, str],
        excluded: Optional[List[str]] = None,
        **kwargs
    ) -> None:
        """Broadcast content inside request body to all the connected connections in the same hub.

        Broadcast content inside request body to all the connected connections in the same hub.

        :param hub: Target hub name, which should start with alphabetic characters and only contain
         alpha-numeric characters or underscore.
        :type hub: str
        :param data:
        :type data: str, str
        :param excluded: Excluded connection Ids.
        :type excluded: list[str]
        :keyword str content_type: Media type of the body sent to the API.
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        content_type = kwargs.pop("content_type", "application/octet-stream")

        # Construct URL
        url = self.post_broadcast.metadata['url']  # type: ignore
        path_format_arguments = {
            'hub': self._serialize.url("hub", hub, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if excluded is not None:
            query_parameters['excluded'] = self._serialize.query("excluded", excluded, '[str]')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')

        # Construct and send request
        body_content_kwargs = {}  # type: Dict[str, Any]
        if header_parameters['Content-Type'] in ['application/octet-stream']:
            body_content_kwargs['stream_content'] = data
        elif header_parameters['Content-Type'] in ['text/plain']:
            body_content = self._serialize.body(data, 'str')
            body_content_kwargs['content'] = body_content
        else:
            raise ValueError(
                "Content type {} is not valid for this operation".format(header_parameters['Content-Type'])
            )
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
          return cls(pipeline_response, None, {})

    post_broadcast.metadata = {'url': '/ws/api/v1/hubs/{hub}'}  # type: ignore

    async def post_send_to_default_hub_user(
        self,
        id: str,
        data: Union[str, str],
        **kwargs
    ) -> None:
        """Send content inside request body to the specific user.

        Send content inside request body to the specific user.

        :param id: The user Id.
        :type id: str
        :param data:
        :type data: str, str
        :keyword str content_type: Media type of the body sent to the API.
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        content_type = kwargs.pop("content_type", "application/octet-stream")

        # Construct URL
        url = self.post_send_to_default_hub_user.metadata['url']  # type: ignore
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')

        # Construct and send request
        body_content_kwargs = {}  # type: Dict[str, Any]
        if header_parameters['Content-Type'] in ['application/octet-stream']:
            body_content_kwargs['stream_content'] = data
        elif header_parameters['Content-Type'] in ['text/plain']:
            body_content = self._serialize.body(data, 'str')
            body_content_kwargs['content'] = body_content
        else:
            raise ValueError(
                "Content type {} is not valid for this operation".format(header_parameters['Content-Type'])
            )
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
          return cls(pipeline_response, None, {})

    post_send_to_default_hub_user.metadata = {'url': '/ws/api/v1/users/{id}'}  # type: ignore

    async def post_send_to_user(
        self,
        hub: str,
        id: str,
        data: Union[str, str],
        **kwargs
    ) -> None:
        """Send content inside request body to the specific user.

        Send content inside request body to the specific user.

        :param hub: Target hub name, which should start with alphabetic characters and only contain
         alpha-numeric characters or underscore.
        :type hub: str
        :param id: The user Id.
        :type id: str
        :param data:
        :type data: str, str
        :keyword str content_type: Media type of the body sent to the API.
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        content_type = kwargs.pop("content_type", "application/octet-stream")

        # Construct URL
        url = self.post_send_to_user.metadata['url']  # type: ignore
        path_format_arguments = {
            'hub': self._serialize.url("hub", hub, 'str'),
            'id': self._serialize.url("id", id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')

        # Construct and send request
        body_content_kwargs = {}  # type: Dict[str, Any]
        if header_parameters['Content-Type'] in ['application/octet-stream']:
            body_content_kwargs['stream_content'] = data
        elif header_parameters['Content-Type'] in ['text/plain']:
            body_content = self._serialize.body(data, 'str')
            body_content_kwargs['content'] = body_content
        else:
            raise ValueError(
                "Content type {} is not valid for this operation".format(header_parameters['Content-Type'])
            )
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
          return cls(pipeline_response, None, {})

    post_send_to_user.metadata = {'url': '/ws/api/v1/hubs/{hub}/users/{id}'}  # type: ignore

    async def post_send_to_default_hub_connection(
        self,
        connection_id: str,
        data: Union[str, str],
        **kwargs
    ) -> None:
        """Send content inside request body to the specific connection.

        Send content inside request body to the specific connection.

        :param connection_id: The connection Id.
        :type connection_id: str
        :param data:
        :type data: str, str
        :keyword str content_type: Media type of the body sent to the API.
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        content_type = kwargs.pop("content_type", "application/octet-stream")

        # Construct URL
        url = self.post_send_to_default_hub_connection.metadata['url']  # type: ignore
        path_format_arguments = {
            'connectionId': self._serialize.url("connection_id", connection_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')

        # Construct and send request
        body_content_kwargs = {}  # type: Dict[str, Any]
        if header_parameters['Content-Type'] in ['application/octet-stream']:
            body_content_kwargs['stream_content'] = data
        elif header_parameters['Content-Type'] in ['text/plain']:
            body_content = self._serialize.body(data, 'str')
            body_content_kwargs['content'] = body_content
        else:
            raise ValueError(
                "Content type {} is not valid for this operation".format(header_parameters['Content-Type'])
            )
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
          return cls(pipeline_response, None, {})

    post_send_to_default_hub_connection.metadata = {'url': '/ws/api/v1/connections/{connectionId}'}  # type: ignore

    async def get_check_default_hub_connection_existence(
        self,
        connection_id: str,
        **kwargs
    ) -> None:
        """Check if the connection with the given connectionId exists.

        Check if the connection with the given connectionId exists.

        :param connection_id:
        :type connection_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.get_check_default_hub_connection_existence.metadata['url']  # type: ignore
        path_format_arguments = {
            'connectionId': self._serialize.url("connection_id", connection_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]

        # Construct and send request
        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
          return cls(pipeline_response, None, {})

    get_check_default_hub_connection_existence.metadata = {'url': '/ws/api/v1/connections/{connectionId}'}  # type: ignore

    async def head_check_default_hub_connection_existence(
        self,
        connection_id: str,
        **kwargs
    ) -> None:
        """Check if the connection with the given connectionId exists.

        Check if the connection with the given connectionId exists.

        :param connection_id:
        :type connection_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.head_check_default_hub_connection_existence.metadata['url']  # type: ignore
        path_format_arguments = {
            'connectionId': self._serialize.url("connection_id", connection_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]

        # Construct and send request
        request = self._client.head(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
          return cls(pipeline_response, None, {})

    head_check_default_hub_connection_existence.metadata = {'url': '/ws/api/v1/connections/{connectionId}'}  # type: ignore

    async def delete_close_default_hub_client_connection(
        self,
        connection_id: str,
        reason: Optional[str] = None,
        **kwargs
    ) -> None:
        """Close the client connection.

        Close the client connection.

        :param connection_id:
        :type connection_id: str
        :param reason:
        :type reason: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.delete_close_default_hub_client_connection.metadata['url']  # type: ignore
        path_format_arguments = {
            'connectionId': self._serialize.url("connection_id", connection_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if reason is not None:
            query_parameters['reason'] = self._serialize.query("reason", reason, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]

        # Construct and send request
        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
          return cls(pipeline_response, None, {})

    delete_close_default_hub_client_connection.metadata = {'url': '/ws/api/v1/connections/{connectionId}'}  # type: ignore

    async def post_send_to_connection(
        self,
        hub: str,
        connection_id: str,
        data: Union[str, str],
        **kwargs
    ) -> None:
        """Send content inside request body to the specific connection.

        Send content inside request body to the specific connection.

        :param hub: Target hub name, which should start with alphabetic characters and only contain
         alpha-numeric characters or underscore.
        :type hub: str
        :param connection_id: The connection Id.
        :type connection_id: str
        :param data:
        :type data: str, str
        :keyword str content_type: Media type of the body sent to the API.
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        content_type = kwargs.pop("content_type", "application/octet-stream")

        # Construct URL
        url = self.post_send_to_connection.metadata['url']  # type: ignore
        path_format_arguments = {
            'hub': self._serialize.url("hub", hub, 'str'),
            'connectionId': self._serialize.url("connection_id", connection_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')

        # Construct and send request
        body_content_kwargs = {}  # type: Dict[str, Any]
        if header_parameters['Content-Type'] in ['application/octet-stream']:
            body_content_kwargs['stream_content'] = data
        elif header_parameters['Content-Type'] in ['text/plain']:
            body_content = self._serialize.body(data, 'str')
            body_content_kwargs['content'] = body_content
        else:
            raise ValueError(
                "Content type {} is not valid for this operation".format(header_parameters['Content-Type'])
            )
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
          return cls(pipeline_response, None, {})

    post_send_to_connection.metadata = {'url': '/ws/api/v1/hubs/{hub}/connections/{connectionId}'}  # type: ignore

    async def get_check_connection_existence(
        self,
        hub: str,
        connection_id: str,
        **kwargs
    ) -> None:
        """Check if the connection with the given connectionId exists.

        Check if the connection with the given connectionId exists.

        :param hub:
        :type hub: str
        :param connection_id:
        :type connection_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.get_check_connection_existence.metadata['url']  # type: ignore
        path_format_arguments = {
            'hub': self._serialize.url("hub", hub, 'str'),
            'connectionId': self._serialize.url("connection_id", connection_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]

        # Construct and send request
        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
          return cls(pipeline_response, None, {})

    get_check_connection_existence.metadata = {'url': '/ws/api/v1/hubs/{hub}/connections/{connectionId}'}  # type: ignore

    async def head_check_connection_existence(
        self,
        hub: str,
        connection_id: str,
        **kwargs
    ) -> None:
        """Check if the connection with the given connectionId exists.

        Check if the connection with the given connectionId exists.

        :param hub:
        :type hub: str
        :param connection_id:
        :type connection_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.head_check_connection_existence.metadata['url']  # type: ignore
        path_format_arguments = {
            'hub': self._serialize.url("hub", hub, 'str'),
            'connectionId': self._serialize.url("connection_id", connection_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]

        # Construct and send request
        request = self._client.head(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
          return cls(pipeline_response, None, {})

    head_check_connection_existence.metadata = {'url': '/ws/api/v1/hubs/{hub}/connections/{connectionId}'}  # type: ignore

    async def delete_close_client_connection(
        self,
        hub: str,
        connection_id: str,
        reason: Optional[str] = None,
        **kwargs
    ) -> None:
        """Close the client connection.

        Close the client connection.

        :param hub:
        :type hub: str
        :param connection_id:
        :type connection_id: str
        :param reason:
        :type reason: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.delete_close_client_connection.metadata['url']  # type: ignore
        path_format_arguments = {
            'hub': self._serialize.url("hub", hub, 'str'),
            'connectionId': self._serialize.url("connection_id", connection_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if reason is not None:
            query_parameters['reason'] = self._serialize.query("reason", reason, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]

        # Construct and send request
        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
          return cls(pipeline_response, None, {})

    delete_close_client_connection.metadata = {'url': '/ws/api/v1/hubs/{hub}/connections/{connectionId}'}  # type: ignore

    async def post_default_hub_group_broadcast(
        self,
        group: str,
        data: Union[str, str],
        excluded: Optional[List[str]] = None,
        **kwargs
    ) -> None:
        """Send content inside request body to a group of connections.

        Send content inside request body to a group of connections.

        :param group: Target group name, which length should be greater than 0 and less than 1025.
        :type group: str
        :param data:
        :type data: str, str
        :param excluded: Excluded connection Ids.
        :type excluded: list[str]
        :keyword str content_type: Media type of the body sent to the API.
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        content_type = kwargs.pop("content_type", "application/octet-stream")

        # Construct URL
        url = self.post_default_hub_group_broadcast.metadata['url']  # type: ignore
        path_format_arguments = {
            'group': self._serialize.url("group", group, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if excluded is not None:
            query_parameters['excluded'] = self._serialize.query("excluded", excluded, '[str]')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')

        # Construct and send request
        body_content_kwargs = {}  # type: Dict[str, Any]
        if header_parameters['Content-Type'] in ['application/octet-stream']:
            body_content_kwargs['stream_content'] = data
        elif header_parameters['Content-Type'] in ['text/plain']:
            body_content = self._serialize.body(data, 'str')
            body_content_kwargs['content'] = body_content
        else:
            raise ValueError(
                "Content type {} is not valid for this operation".format(header_parameters['Content-Type'])
            )
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
          return cls(pipeline_response, None, {})

    post_default_hub_group_broadcast.metadata = {'url': '/ws/api/v1/groups/{group}'}  # type: ignore

    async def get_check_default_hub_group_existence(
        self,
        group: str,
        **kwargs
    ) -> None:
        """Check if there are any client connections inside the given group.

        Check if there are any client connections inside the given group.

        :param group:
        :type group: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.get_check_default_hub_group_existence.metadata['url']  # type: ignore
        path_format_arguments = {
            'group': self._serialize.url("group", group, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]

        # Construct and send request
        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
          return cls(pipeline_response, None, {})

    get_check_default_hub_group_existence.metadata = {'url': '/ws/api/v1/groups/{group}'}  # type: ignore

    async def head_check_default_hub_group_existence(
        self,
        group: str,
        **kwargs
    ) -> None:
        """Check if there are any client connections inside the given group.

        Check if there are any client connections inside the given group.

        :param group:
        :type group: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.head_check_default_hub_group_existence.metadata['url']  # type: ignore
        path_format_arguments = {
            'group': self._serialize.url("group", group, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]

        # Construct and send request
        request = self._client.head(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
          return cls(pipeline_response, None, {})

    head_check_default_hub_group_existence.metadata = {'url': '/ws/api/v1/groups/{group}'}  # type: ignore

    async def post_group_broadcast(
        self,
        hub: str,
        group: str,
        data: Union[str, str],
        excluded: Optional[List[str]] = None,
        **kwargs
    ) -> None:
        """Send content inside request body to a group of connections.

        Send content inside request body to a group of connections.

        :param hub: Target hub name, which should start with alphabetic characters and only contain
         alpha-numeric characters or underscore.
        :type hub: str
        :param group: Target group name, which length should be greater than 0 and less than 1025.
        :type group: str
        :param data:
        :type data: str, str
        :param excluded: Excluded connection Ids.
        :type excluded: list[str]
        :keyword str content_type: Media type of the body sent to the API.
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        content_type = kwargs.pop("content_type", "application/octet-stream")

        # Construct URL
        url = self.post_group_broadcast.metadata['url']  # type: ignore
        path_format_arguments = {
            'hub': self._serialize.url("hub", hub, 'str'),
            'group': self._serialize.url("group", group, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if excluded is not None:
            query_parameters['excluded'] = self._serialize.query("excluded", excluded, '[str]')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')

        # Construct and send request
        body_content_kwargs = {}  # type: Dict[str, Any]
        if header_parameters['Content-Type'] in ['application/octet-stream']:
            body_content_kwargs['stream_content'] = data
        elif header_parameters['Content-Type'] in ['text/plain']:
            body_content = self._serialize.body(data, 'str')
            body_content_kwargs['content'] = body_content
        else:
            raise ValueError(
                "Content type {} is not valid for this operation".format(header_parameters['Content-Type'])
            )
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
          return cls(pipeline_response, None, {})

    post_group_broadcast.metadata = {'url': '/ws/api/v1/hubs/{hub}/groups/{group}'}  # type: ignore

    async def get_check_group_existence(
        self,
        hub: str,
        group: str,
        **kwargs
    ) -> None:
        """Check if there are any client connections inside the given group.

        Check if there are any client connections inside the given group.

        :param hub:
        :type hub: str
        :param group:
        :type group: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.get_check_group_existence.metadata['url']  # type: ignore
        path_format_arguments = {
            'hub': self._serialize.url("hub", hub, 'str'),
            'group': self._serialize.url("group", group, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]

        # Construct and send request
        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
          return cls(pipeline_response, None, {})

    get_check_group_existence.metadata = {'url': '/ws/api/v1/hubs/{hub}/groups/{group}'}  # type: ignore

    async def head_check_group_existence(
        self,
        hub: str,
        group: str,
        **kwargs
    ) -> None:
        """Check if there are any client connections inside the given group.

        Check if there are any client connections inside the given group.

        :param hub:
        :type hub: str
        :param group:
        :type group: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.head_check_group_existence.metadata['url']  # type: ignore
        path_format_arguments = {
            'hub': self._serialize.url("hub", hub, 'str'),
            'group': self._serialize.url("group", group, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]

        # Construct and send request
        request = self._client.head(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
          return cls(pipeline_response, None, {})

    head_check_group_existence.metadata = {'url': '/ws/api/v1/hubs/{hub}/groups/{group}'}  # type: ignore

    async def get_check_default_hub_user_existence(
        self,
        user: str,
        **kwargs
    ) -> None:
        """Check if there are any client connections connected for the given user.

        Check if there are any client connections connected for the given user.

        :param user:
        :type user: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.get_check_default_hub_user_existence.metadata['url']  # type: ignore
        path_format_arguments = {
            'user': self._serialize.url("user", user, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]

        # Construct and send request
        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
          return cls(pipeline_response, None, {})

    get_check_default_hub_user_existence.metadata = {'url': '/ws/api/v1/users/{user}'}  # type: ignore

    async def head_check_default_hub_user_existence(
        self,
        user: str,
        **kwargs
    ) -> None:
        """Check if there are any client connections connected for the given user.

        Check if there are any client connections connected for the given user.

        :param user:
        :type user: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.head_check_default_hub_user_existence.metadata['url']  # type: ignore
        path_format_arguments = {
            'user': self._serialize.url("user", user, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]

        # Construct and send request
        request = self._client.head(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
          return cls(pipeline_response, None, {})

    head_check_default_hub_user_existence.metadata = {'url': '/ws/api/v1/users/{user}'}  # type: ignore

    async def put_add_connection_to_default_hub_group(
        self,
        group: str,
        connection_id: str,
        **kwargs
    ) -> None:
        """Add a connection to the target group.

        Add a connection to the target group.

        :param group: Target group name, which length should be greater than 0 and less than 1025.
        :type group: str
        :param connection_id: Target connection Id.
        :type connection_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.put_add_connection_to_default_hub_group.metadata['url']  # type: ignore
        path_format_arguments = {
            'group': self._serialize.url("group", group, 'str'),
            'connectionId': self._serialize.url("connection_id", connection_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]

        # Construct and send request
        request = self._client.put(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
          return cls(pipeline_response, None, {})

    put_add_connection_to_default_hub_group.metadata = {'url': '/ws/api/v1/groups/{group}/connections/{connectionId}'}  # type: ignore

    async def delete_remove_connection_from_default_hub_group(
        self,
        group: str,
        connection_id: str,
        **kwargs
    ) -> None:
        """Remove a connection from the target group.

        Remove a connection from the target group.

        :param group: Target group name, which length should be greater than 0 and less than 1025.
        :type group: str
        :param connection_id: Target connection Id.
        :type connection_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.delete_remove_connection_from_default_hub_group.metadata['url']  # type: ignore
        path_format_arguments = {
            'group': self._serialize.url("group", group, 'str'),
            'connectionId': self._serialize.url("connection_id", connection_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]

        # Construct and send request
        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
          return cls(pipeline_response, None, {})

    delete_remove_connection_from_default_hub_group.metadata = {'url': '/ws/api/v1/groups/{group}/connections/{connectionId}'}  # type: ignore

    async def get_check_user_existence_in_default_hub_group(
        self,
        group: str,
        user: str,
        **kwargs
    ) -> None:
        """Check whether a user exists in the target group.

        Check whether a user exists in the target group.

        :param group: Target group name, which length should be greater than 0 and less than 1025.
        :type group: str
        :param user: Target user Id.
        :type user: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.get_check_user_existence_in_default_hub_group.metadata['url']  # type: ignore
        path_format_arguments = {
            'group': self._serialize.url("group", group, 'str'),
            'user': self._serialize.url("user", user, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]

        # Construct and send request
        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
          return cls(pipeline_response, None, {})

    get_check_user_existence_in_default_hub_group.metadata = {'url': '/ws/api/v1/groups/{group}/users/{user}'}  # type: ignore

    async def head_check_user_existence_in_default_hub_group(
        self,
        group: str,
        user: str,
        **kwargs
    ) -> None:
        """Check whether a user exists in the target group.

        Check whether a user exists in the target group.

        :param group: Target group name, which length should be greater than 0 and less than 1025.
        :type group: str
        :param user: Target user Id.
        :type user: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.head_check_user_existence_in_default_hub_group.metadata['url']  # type: ignore
        path_format_arguments = {
            'group': self._serialize.url("group", group, 'str'),
            'user': self._serialize.url("user", user, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]

        # Construct and send request
        request = self._client.head(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
          return cls(pipeline_response, None, {})

    head_check_user_existence_in_default_hub_group.metadata = {'url': '/ws/api/v1/groups/{group}/users/{user}'}  # type: ignore

    async def put_add_user_to_default_hub_group(
        self,
        group: str,
        user: str,
        ttl: Optional[int] = None,
        **kwargs
    ) -> None:
        """Add a user to the target group.

        Add a user to the target group.

        :param group: Target group name, which length should be greater than 0 and less than 1025.
        :type group: str
        :param user: Target user Id.
        :type user: str
        :param ttl: Specifies the seconds that the user exists in the group. If not set, the user lives
         in the group forever.
        :type ttl: int
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.put_add_user_to_default_hub_group.metadata['url']  # type: ignore
        path_format_arguments = {
            'group': self._serialize.url("group", group, 'str'),
            'user': self._serialize.url("user", user, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if ttl is not None:
            query_parameters['ttl'] = self._serialize.query("ttl", ttl, 'int')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]

        # Construct and send request
        request = self._client.put(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
          return cls(pipeline_response, None, {})

    put_add_user_to_default_hub_group.metadata = {'url': '/ws/api/v1/groups/{group}/users/{user}'}  # type: ignore

    async def delete_remove_user_from_default_hub_group(
        self,
        group: str,
        user: str,
        **kwargs
    ) -> None:
        """Remove a user from the target group.

        Remove a user from the target group.

        :param group: Target group name, which length should be greater than 0 and less than 1025.
        :type group: str
        :param user: Target user Id.
        :type user: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.delete_remove_user_from_default_hub_group.metadata['url']  # type: ignore
        path_format_arguments = {
            'group': self._serialize.url("group", group, 'str'),
            'user': self._serialize.url("user", user, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]

        # Construct and send request
        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
          return cls(pipeline_response, None, {})

    delete_remove_user_from_default_hub_group.metadata = {'url': '/ws/api/v1/groups/{group}/users/{user}'}  # type: ignore

    async def delete_remove_user_from_all_default_hub_groups(
        self,
        user: str,
        **kwargs
    ) -> None:
        """Remove a user from all groups.

        Remove a user from all groups.

        :param user: Target user Id.
        :type user: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.delete_remove_user_from_all_default_hub_groups.metadata['url']  # type: ignore
        path_format_arguments = {
            'user': self._serialize.url("user", user, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]

        # Construct and send request
        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
          return cls(pipeline_response, None, {})

    delete_remove_user_from_all_default_hub_groups.metadata = {'url': '/ws/api/v1/users/{user}/groups'}  # type: ignore

    async def get_check_user_existence(
        self,
        hub: str,
        user: str,
        **kwargs
    ) -> None:
        """Check if there are any client connections connected for the given user.

        Check if there are any client connections connected for the given user.

        :param hub:
        :type hub: str
        :param user:
        :type user: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.get_check_user_existence.metadata['url']  # type: ignore
        path_format_arguments = {
            'hub': self._serialize.url("hub", hub, 'str'),
            'user': self._serialize.url("user", user, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]

        # Construct and send request
        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
          return cls(pipeline_response, None, {})

    get_check_user_existence.metadata = {'url': '/ws/api/v1/hubs/{hub}/users/{user}'}  # type: ignore

    async def head_check_user_existence(
        self,
        hub: str,
        user: str,
        **kwargs
    ) -> None:
        """Check if there are any client connections connected for the given user.

        Check if there are any client connections connected for the given user.

        :param hub:
        :type hub: str
        :param user:
        :type user: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.head_check_user_existence.metadata['url']  # type: ignore
        path_format_arguments = {
            'hub': self._serialize.url("hub", hub, 'str'),
            'user': self._serialize.url("user", user, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]

        # Construct and send request
        request = self._client.head(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
          return cls(pipeline_response, None, {})

    head_check_user_existence.metadata = {'url': '/ws/api/v1/hubs/{hub}/users/{user}'}  # type: ignore

    async def put_add_connection_to_group(
        self,
        hub: str,
        group: str,
        connection_id: str,
        **kwargs
    ) -> None:
        """Add a connection to the target group.

        Add a connection to the target group.

        :param hub: Target hub name, which should start with alphabetic characters and only contain
         alpha-numeric characters or underscore.
        :type hub: str
        :param group: Target group name, which length should be greater than 0 and less than 1025.
        :type group: str
        :param connection_id: Target connection Id.
        :type connection_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.put_add_connection_to_group.metadata['url']  # type: ignore
        path_format_arguments = {
            'hub': self._serialize.url("hub", hub, 'str'),
            'group': self._serialize.url("group", group, 'str'),
            'connectionId': self._serialize.url("connection_id", connection_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]

        # Construct and send request
        request = self._client.put(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
          return cls(pipeline_response, None, {})

    put_add_connection_to_group.metadata = {'url': '/ws/api/v1/hubs/{hub}/groups/{group}/connections/{connectionId}'}  # type: ignore

    async def delete_remove_connection_from_group(
        self,
        hub: str,
        group: str,
        connection_id: str,
        **kwargs
    ) -> None:
        """Remove a connection from the target group.

        Remove a connection from the target group.

        :param hub: Target hub name, which should start with alphabetic characters and only contain
         alpha-numeric characters or underscore.
        :type hub: str
        :param group: Target group name, which length should be greater than 0 and less than 1025.
        :type group: str
        :param connection_id: Target connection Id.
        :type connection_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.delete_remove_connection_from_group.metadata['url']  # type: ignore
        path_format_arguments = {
            'hub': self._serialize.url("hub", hub, 'str'),
            'group': self._serialize.url("group", group, 'str'),
            'connectionId': self._serialize.url("connection_id", connection_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]

        # Construct and send request
        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
          return cls(pipeline_response, None, {})

    delete_remove_connection_from_group.metadata = {'url': '/ws/api/v1/hubs/{hub}/groups/{group}/connections/{connectionId}'}  # type: ignore

    async def get_check_user_existence_in_group(
        self,
        hub: str,
        group: str,
        user: str,
        **kwargs
    ) -> None:
        """Check whether a user exists in the target group.

        Check whether a user exists in the target group.

        :param hub: Target hub name, which should start with alphabetic characters and only contain
         alpha-numeric characters or underscore.
        :type hub: str
        :param group: Target group name, which length should be greater than 0 and less than 1025.
        :type group: str
        :param user: Target user Id.
        :type user: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.get_check_user_existence_in_group.metadata['url']  # type: ignore
        path_format_arguments = {
            'hub': self._serialize.url("hub", hub, 'str'),
            'group': self._serialize.url("group", group, 'str'),
            'user': self._serialize.url("user", user, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]

        # Construct and send request
        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
          return cls(pipeline_response, None, {})

    get_check_user_existence_in_group.metadata = {'url': '/ws/api/v1/hubs/{hub}/groups/{group}/users/{user}'}  # type: ignore

    async def head_check_user_existence_in_group(
        self,
        hub: str,
        group: str,
        user: str,
        **kwargs
    ) -> None:
        """Check whether a user exists in the target group.

        Check whether a user exists in the target group.

        :param hub: Target hub name, which should start with alphabetic characters and only contain
         alpha-numeric characters or underscore.
        :type hub: str
        :param group: Target group name, which length should be greater than 0 and less than 1025.
        :type group: str
        :param user: Target user Id.
        :type user: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.head_check_user_existence_in_group.metadata['url']  # type: ignore
        path_format_arguments = {
            'hub': self._serialize.url("hub", hub, 'str'),
            'group': self._serialize.url("group", group, 'str'),
            'user': self._serialize.url("user", user, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]

        # Construct and send request
        request = self._client.head(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
          return cls(pipeline_response, None, {})

    head_check_user_existence_in_group.metadata = {'url': '/ws/api/v1/hubs/{hub}/groups/{group}/users/{user}'}  # type: ignore

    async def put_add_user_to_group(
        self,
        hub: str,
        group: str,
        user: str,
        ttl: Optional[int] = None,
        **kwargs
    ) -> None:
        """Add a user to the target group.

        Add a user to the target group.

        :param hub: Target hub name, which should start with alphabetic characters and only contain
         alpha-numeric characters or underscore.
        :type hub: str
        :param group: Target group name, which length should be greater than 0 and less than 1025.
        :type group: str
        :param user: Target user Id.
        :type user: str
        :param ttl: Specifies the seconds that the user exists in the group. If not set, the user lives
         in the group forever.
        :type ttl: int
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.put_add_user_to_group.metadata['url']  # type: ignore
        path_format_arguments = {
            'hub': self._serialize.url("hub", hub, 'str'),
            'group': self._serialize.url("group", group, 'str'),
            'user': self._serialize.url("user", user, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if ttl is not None:
            query_parameters['ttl'] = self._serialize.query("ttl", ttl, 'int')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]

        # Construct and send request
        request = self._client.put(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
          return cls(pipeline_response, None, {})

    put_add_user_to_group.metadata = {'url': '/ws/api/v1/hubs/{hub}/groups/{group}/users/{user}'}  # type: ignore

    async def delete_remove_user_from_group(
        self,
        hub: str,
        group: str,
        user: str,
        **kwargs
    ) -> None:
        """Remove a user from the target group.

        Remove a user from the target group.

        :param hub: Target hub name, which should start with alphabetic characters and only contain
         alpha-numeric characters or underscore.
        :type hub: str
        :param group: Target group name, which length should be greater than 0 and less than 1025.
        :type group: str
        :param user: Target user Id.
        :type user: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.delete_remove_user_from_group.metadata['url']  # type: ignore
        path_format_arguments = {
            'hub': self._serialize.url("hub", hub, 'str'),
            'group': self._serialize.url("group", group, 'str'),
            'user': self._serialize.url("user", user, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]

        # Construct and send request
        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
          return cls(pipeline_response, None, {})

    delete_remove_user_from_group.metadata = {'url': '/ws/api/v1/hubs/{hub}/groups/{group}/users/{user}'}  # type: ignore

    async def delete_remove_user_from_all_groups(
        self,
        hub: str,
        user: str,
        **kwargs
    ) -> None:
        """Remove a user from all groups.

        Remove a user from all groups.

        :param hub: Target hub name, which should start with alphabetic characters and only contain
         alpha-numeric characters or underscore.
        :type hub: str
        :param user: Target user Id.
        :type user: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.delete_remove_user_from_all_groups.metadata['url']  # type: ignore
        path_format_arguments = {
            'hub': self._serialize.url("hub", hub, 'str'),
            'user': self._serialize.url("user", user, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]

        # Construct and send request
        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
          return cls(pipeline_response, None, {})

    delete_remove_user_from_all_groups.metadata = {'url': '/ws/api/v1/hubs/{hub}/users/{user}/groups'}  # type: ignore
